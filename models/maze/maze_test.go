package maze

import (
	"green/utils/intUtil"
	"testing"
)

func TestMaze_GetDestinationCoordinates(t *testing.T) {
	tests := []struct {
		expected Maze
		in       []int
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0, 1, 1, 1},
				{1, 0, 0, 0, 0, 0, 0, 1},
				{1, 0, 1, 1, 1, 0, 1, 1},
				{1, 0, 0, 0, 1, 0, 0, 1},
				{1, 1, 1, 0, 1, 1, 0, 1},
				{1, 0, 0, 0, 1, 0, 0, 1},
				{1, 0, 1, 1, 1, 0, 1, 1},
				{1, 0, 0, 2, 0, 0, 0, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
			}},
			[]int{0, 4},
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{1, 0, 0, 0, 1, 0, 0, 1},
			{1, 1, 1, 0, 1, 1, 0, 1},
			{1, 0, 0, 0, 1, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{0, 0, 0, 2, 0, 0, 0, 1},
			{1, 1, 1, 1, 1, 1, 1, 1},
		}},
			[]int{7, 0},
		},
	}

	for _, test := range tests {
		dest1, dest2 := test.expected.GetDestinationCoordinates()
		res := dest1*10 + dest2
		if res != intUtil.Join(test.in) {
			t.Fail()
		}
	}
}

func TestMaze_GetSourceCoordinates(t *testing.T) {
	tests := []struct {
		expected Maze
		in       []int
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0, 1, 1, 1},
				{1, 0, 0, 0, 0, 0, 0, 1},
				{1, 0, 1, 1, 1, 0, 1, 1},
				{1, 0, 0, 0, 1, 0, 0, 1},
				{1, 1, 1, 0, 1, 1, 0, 1},
				{1, 0, 0, 0, 1, 0, 0, 1},
				{1, 0, 1, 1, 1, 0, 1, 1},
				{1, 0, 0, 2, 0, 0, 0, 1},
				{1, 1, 1, 1, 1, 1, 1, 1},
			}},
			[]int{7, 3},
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{1, 0, 0, 0, 1, 0, 0, 1},
			{1, 1, 1, 0, 1, 1, 0, 1},
			{1, 2, 0, 0, 1, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1},
			{1, 1, 1, 1, 1, 1, 1, 1},
		}},
			[]int{5, 1},
		},
	}
	for _, test := range tests {
		dest1, dest2 := test.expected.GetSourceCoordinates()
		res := dest1*10 + dest2
		if res != intUtil.Join(test.in) {
			t.Fail()
		}
	}
}
func TestMaze_GetXDimension(t *testing.T) {
	tests := []struct {
		expected Maze
		in       int
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0, 1, 1, 1},
				{1, 0, 0, 0, 0, 0, 0, 1},
				{1, 0, 1, 1, 1, 0, 1, 1},
				{1, 0, 0, 0, 1, 0, 0, 1},
			}},
			4,
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{1, 0, 0, 0, 1, 0, 0, 1},
			{1, 1, 1, 0, 1, 1, 0, 1},
			{1, 2, 0, 0, 1, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1},
			{1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1},
			{1, 0, 1, 1, 1, 0, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1},
		}},
			12,
		},
	}
	for _, test := range tests {
		if test.expected.GetXDimension() != test.in {
			t.Fail()
		}
	}
}

func TestMaze_GetYDimension(t *testing.T) {
	tests := []struct {
		expected Maze
		in       int
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0},
				{1, 0, 0, 0, 0},
				{1, 0, 1, 1, 1},
				{1, 0, 0, 0, 1},
			}},
			5,
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		}},
			16,
		},
	}
	for _, test := range tests {
		if test.expected.GetYDimension() != test.in {
			t.Fail()
		}
	}
}

func TestMaze_IsRectangular(t *testing.T) {
	tests := []struct {
		expected Maze
		in       bool
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0},
				{1, 0, 0, 0, 0},
				{1, 0, 1, 1, 1},
				{1, 0, 0, 0, 1},
			}},
			false,
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		}},
			true,
		},
	}
	for _, test := range tests {
		if test.expected.IsRectangular() != test.in {
			t.Fail()
		}
	}
}

func TestMaze_IsValidMazeSpaceValues(t *testing.T) {
	tests := []struct {
		expected Maze
		in       bool
	}{
		{
			Maze{Maze: [][]int32{
				{1, 1, 1, 1, 0},
				{1, 0, 0, 0, 0},
				{1, 0, 1, 1, 1},
				{1, 0, 0, 0, 1},
			}},
			true,
		},
		{Maze{Maze: [][]int32{
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{9, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 0, 4, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 4, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 9, 1, 1},
			{0, 0, 0, 9, 0, 0, 0, 6, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 2, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{9, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{9, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{9, 0, 0, 0, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9},
			{9, 0, 0, 0, 0, 6, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
			{9, 0, 0, 0, 6, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1},
		}},
			false,
		},
	}
	for _, test := range tests {
		if test.expected.IsValidMazeSpaceValues() != test.in {
			t.Fail()
		}
	}
}
